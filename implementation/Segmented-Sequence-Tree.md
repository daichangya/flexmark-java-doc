
需要对分段序列进行优化,该分段不存储针对
每个字符但都相同不会影响通过`charAt(n)`随机访问字符。

一些已知的方法是[Interval tree]用于重叠多个时间间隔,
[Segment tree - Wikipedia]或[Binary search tree]。所有查询时间均为$ `O(log \ n)` $。

实际上,可以搜索$ `O(log \ n)` $,其中* n *是可以显示为具有
使用每线程缓存进行顺序和段内随机访问的时间几乎恒定
当前段索引和段数据,并附加检查下一个/上一个段
当当前句段不匹配时命中,在对给定的二进制搜索之前
指数。

另一个理想的优化方法是让每个`BasedSequence`提供其细分信息
有效地允许构建一个新的分段序列,该分段序列由
分段序列。能够使用偏移量和长度提取段信息
非常需要母体结构的亚序列,这将减少
分段序列。

树结构像它代表的序列一样是不可变的,因此创建成本不菲
并查询无需担心插入/删除/复制操作的效率。

### 分段二叉树
    

查询时间为$ `O(log \ n)` $,其中* n *是序列中不需要的段数
存储每个字符的任何信息,即有序段的聚合长度的二进制树
该序列是分段序列的理想选择。

聚合长度数组`int[]`提供了二叉树结构。中间的条目是
搜索的根节点。

紧凑存储的优势非常明显,特别是对于片段少的长序列。
当前的实现对序列中的每个字符使用了`int`,是本机Java的三倍
字符存储。巨大的内存占用量利用`SegmentedSequence`进行累加
`HtmlRenderer`和`Formatter`输出的文本对于大型文件是有问题的。在测试中
`Formatter`的上限大约是25万个Markdown源。更大,操作会失败
内存不足异常。运行较小的文件将需要6GB以上的内存。

通过最后使用的段的每个线程缓存,可以减轻顺序访问的查询代价
信息。

如果char索引在缓存的段之内,则可以重新使用该段。如果是在结束之后
的片段,则可以尝试下一个片段。如果是在段开始之前,则
前一段可以尝试。

如果没有匹配项,则应检查第一个和最后一个段以优化顺序字符
从序列的开始或结尾访问序列。

这些测试是`int[]`的快速索引,因此不会造成重罚。此外,失败
测试不会浪费,因为它们可以缩小必须搜索的细分范围。

如果请求的索引在上一个段之前,则应在[0,
prevSeg),如果它大于下一个片段的汇总长度,则搜索范围会缩小
到(nextSeg,endSeg)。

由于所有段均已排序,因此聚合长度数组可以由
段的单次迭代,已完成构建分段序列的操作。
聚合长度的其他变量也不产生任何开销。因此建设
二叉树实际上是免费的。

子序列可以通过定义偏移量和
其部分的长度,消除了搜索多余段和复制的开销
数据的。实际上,对子序列的重用不会对重用父级搜索结构造成任何影响。

通过子序列从父二叉树构造段是另一个加快速度的功能
整体基于树的分段序列使用。

分段序列的总存储开销为`(4 bytes * 2 + per segment overhead) *
number of segments`。每个整数4个字节,一个为汇总长度,另一个为
序列化的段字节数组中段的偏移量。

基本字符不足会增加字符存储的开销,并且所有人都可以访问
对序列数据进行反序列化的代价。这是相对无痛的,因为每个细分市场
包含用于类构造所需的少量数据。字符数据未反序列化并且
访问字符时,直接从序列化字节数据进行字符访问。

仅当肯定确定该段为要使用的段时,才执行反序列化。
即使试图确定上一个或下一个段是否包含索引,**二叉树
使用搜索数据**,而不是序列化的细分数据。

### 分段序列的分段

段存储在字节数组中,并根据需要从连续的字节中反序列化。

每种类型的细分都由一个单独的类表示,所有类均扩展为`SeqSeg`。在科特林,这些
将是一个密封的类。`SeqSeg`仅从`byte[]`反序列化。序列化为
由`Seg`元素中的`SegmentBuilder`执行。

优化了序列化数据以最小化每个段占用的字节数。
*长度和偏移量小于16的内容不需要额外的信息,并且适合第一个字节
  确定细分。
*长度和偏移量根据需要以1、2、3或4字节格式存储以适合数据
*如果段中所有字符的代码<
  256
*重复字符仅存储字符并重复计数
*重复的空格和`\n`仅需要长度,如果<16,则单个字节编码所有
  信息。

偏移量和长度的数值只能为正值和0,长度可以为
段限制为Integer.MAX_VALUE/4,即 0.5 GB,足以满足所需的应用程序。

细分类型:

* `BASE`:代表一段基本序列字符的基本段。1至9个字节,以
  练习可能会平均击中3-4个字节。
  * `ANCHOR`:表示0范围的基本序列字符范围(1到5)的基本段
    个字节,最有可能平均2-3个字节。
* `TEXT`:代表基本序列之外的字符的段,一般情况下为1-5字节+ 2字节
  每个字符
  * `REPEATED_TEXT`:表示重复字符范围的段,为3-7个字节。
    * `REPEATED_SPACE`:重复空格,1到3个字节。大多数可能是1或2个字节。的
      后者最多可处理255个空间。
      * `REPEATED_EOL`:重复`\n`,1至3个字节。大多数可能是1或2个字节。的
        后者最多可以处理255个EOL。
    * `REPEATED_ASCII`:代码<256的重复字符,2-6个字节,最有可能是2个字节
      重复<16,3个字节,最多255个重复。
  * `TEXT_ASCII`:所有字符代码<256的段,1到5个字节加每个字节1个字节
    字符。

序列化段的第一个字节携带有关详细信息的信息并进行序列化
其余字节的格式:

* `SEG_TYPE`:
  * 0b0000_0000:`ANCHOR`:`startOffset`
  * 0b0010_0000:`BASE`:`startOffset`,`length`
  * 0b0100_0000:`TEXT`:`length`:`char[]`
  * 0b0110_0000:`REPEATED_TEXT`:`char`,`length`
  * 0b1000_0000:`TEXT_ASCII`:`length`,`byte[]`
  * 0b1010_0000:`REPEATED_ASCII`:`byte`,`length`,不需要,应将其释放给其他
    用途。
  * 0b1100_0000:`REPEATED_SPACE`:`length`
  * 0b1110_0000:`REPEATED_EOL`:`length`
* `SEG_BYTES`:编码用于段数值的字节数。
  * 0b0001_xxxx:无大小/偏移量字节。如果具有startOffset,则偏移= xxxx,长度= 0,如果具有
    仅长度,然后长度= xxxx,如果同时具有长度和起始偏移量,则无效
  * 0b0000_0000:1个字节用于启动
  * 0b0000_0001:2个字节用于启动
  * 0b0000_0010:3个字节用于启动
  * 0b0000_0011:4个字节用于启动
  * 0b0000_0000:1个字节的长度
  * 0b0000_0100:2个字节的长度
  * 0b0000_1000:3个字节的长度
  * 0b0000_1100:4个字节的长度

[Binary search tree]: https://en.wikipedia.org/wiki/Binary_search_tree "Binary search tree - Wikipedia"
[Interval tree]: https://en.wikipedia.org/wiki/Interval_tree "Interval tree - Wikipedia"
[Segment tree - Wikipedia]: https://en.wikipedia.org/wiki/Segment_tree "Segment tree - Wikipedia"